/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./public/src/app.js":
/*!***************************!*\
  !*** ./public/src/app.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _web_modules_exoteric_r_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./web_modules/exoteric/r.js */ \"./public/src/web_modules/exoteric/r.js\");\n\n\n// state object\n  const AppState = {state:null};\n\n// main startup procedure\nrun();\n\nasync function run() {\n  initState(AppState);\n  Game(AppState).to('#app', 'innerHTML');\n}\n\n// init state \n  function initState(State) {\n    return State.state = {\n      squares: Array(9).fill(''),\n      xIsNext: true,\n    };\n  }\n\n// view funcs\n  function Game({state}) {\n    return _web_modules_exoteric_r_js__WEBPACK_IMPORTED_MODULE_0__.e`\n      <div class=\"game\">\n        <div class=\"game-board\">\n          ${Board(state)}\n        </div>\n        <div class=\"game-info\">\n          <div>${''/* status */}</div>\n          <ol>${''/* TODO */}</ol>\n          <button click=${() => setState(initState(AppState))}>Reset</button>\n        </div>\n      </div>\n    `;\n  }\n\n  function Board(state) {\n    const {squares, xIsNext} = state;\n    const winner = calculateWinner(squares);\n    let status;\n    if (winner) {\n      status = 'Winner: ' + winner;\n    } else {\n      status = 'Next player: ' + (xIsNext ? 'X' : 'O');\n    }\n\n    return _web_modules_exoteric_r_js__WEBPACK_IMPORTED_MODULE_0__.e`\n      <div>\n        <div class=\"status\">${status}</div>\n        <div class=\"board-row\">\n          ${Square({state,i:0})}\n          ${Square({state,i:1})}\n          ${Square({state,i:2})}\n        </div>\n        <div class=\"board-row\">\n          ${Square({state,i:3})}\n          ${Square({state,i:4})}\n          ${Square({state,i:5})}\n        </div>\n        <div class=\"board-row\">\n          ${Square({state,i:6})}\n          ${Square({state,i:7})}\n          ${Square({state,i:8})}\n        </div>\n      </div>\n    `;\n  }\n\n  function Square({state, i}) {\n    return _web_modules_exoteric_r_js__WEBPACK_IMPORTED_MODULE_0__.e`${{key:i+''}}\n      <button class=\"square\" click=${() => handleClick({state,i})}>\n        ${state.squares[i]}\n      </button>\n    `\n  }\n\n// event handler\n  function handleClick({state,i}) {\n    const squares = state.squares.slice();\n    if (calculateWinner(squares) || squares[i]) {\n      return;\n    }\n    squares[i] = state.xIsNext ? 'X' : 'O';\n    setState({\n      squares: squares,\n      xIsNext: !state.xIsNext,\n    });\n  }\n\n// helpers\n  function calculateWinner(squares) {\n    const lines = [\n      [0, 1, 2],\n      [3, 4, 5],\n      [6, 7, 8],\n      [0, 3, 6],\n      [1, 4, 7],\n      [2, 5, 8],\n      [0, 4, 8],\n      [2, 4, 6],\n    ];\n    for (let i = 0; i < lines.length; i++) {\n      const [a, b, c] = lines[i];\n      if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {\n        return squares[a];\n      }\n    }\n    return null;\n  }\n\n  function setState(state) {\n    AppState.state = state;\n    Game(AppState);\n  }\n\n  \n\n\n//# sourceURL=webpack://@dosy-private/front-end/./public/src/app.js?");

/***/ }),

/***/ "./public/src/web_modules/exoteric/common.js":
/*!***************************************************!*\
  !*** ./public/src/web_modules/exoteric/common.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CODE\": () => (/* binding */ CODE)\n/* harmony export */ });\n// common for all r submodules\n  const CODE              = ''+Math.random();\n\n\n\n//# sourceURL=webpack://@dosy-private/front-end/./public/src/web_modules/exoteric/common.js?");

/***/ }),

/***/ "./public/src/web_modules/exoteric/r.js":
/*!**********************************************!*\
  !*** ./public/src/web_modules/exoteric/r.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"d\": () => (/* binding */ d),\n/* harmony export */   \"e\": () => (/* binding */ e),\n/* harmony export */   \"u\": () => (/* binding */ u),\n/* harmony export */   \"x\": () => (/* binding */ x),\n/* harmony export */   \"R\": () => (/* binding */ R),\n/* harmony export */   \"X\": () => (/* binding */ X)\n/* harmony export */ });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./public/src/web_modules/exoteric/common.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types.js */ \"./public/src/web_modules/exoteric/types.js\");\n// r.js\n  // imports\n    \n    \n\n  // backwards compatible alias\n    const skip = markup;\n    const attrskip = attrmarkup;\n\n  // constants\n    const DEBUG             = false;\n    const NULLFUNC          = () => void 0;\n    /* eslint-disable no-useless-escape */\n    const KEYMATCH          = /(?:<!\\-\\-)?(key\\d+)(?:\\-\\->)?/gm;\n    /* eslint-enable no-useless-escape */\n    const ATTRMATCH         = /\\w+=/;\n    const KEYLEN            = 20;\n    const XSS               = () => `Possible XSS / object forgery attack detected. ` +\n                              `Object code could not be verified.`;\n    const OBJ               = () => `Object values not allowed here.`;\n    const UNSET             = () => `Unset values not allowed here.`;\n    const INSERT            = () => `Error inserting template into DOM. ` +\n      `Position must be one of: ` +\n      `replace, beforebegin, afterbegin, beforeend, innerhtml, afterend`;\n    const NOTFOUND          = loc => `Error inserting template into DOM. ` +\n      `Location ${loc} was not found in the document.`;\n    const MOVE              = new class {\n      beforeend   (frag,elem) { elem.appendChild(frag) }\n      beforebegin (frag,elem) { elem.parentNode.insertBefore(frag,elem) }\n      afterend    (frag,elem) { elem.parentNode.insertBefore(frag,elem.nextSibling) }\n      replace     (frag,elem) { elem.parentNode.replaceChild(frag,elem) }\n      afterbegin  (frag,elem) { elem.insertBefore(frag,elem.firstChild) }\n      innerhtml   (frag,elem) { elem.innerHTML = ''; elem.appendChild(frag) }\n    };\n\n  // logging\n    self.onerror = (...v) => (console.log(v, v[0]+'', v[4] && v[4].message, v[4] && v[4].stack), true);\n\n  // type functions\n    const isKey             = v => _types_js__WEBPACK_IMPORTED_MODULE_1__.default.check(_types_js__WEBPACK_IMPORTED_MODULE_1__.default`Key`, v);\n    const isHandlers        = v => _types_js__WEBPACK_IMPORTED_MODULE_1__.default.check(_types_js__WEBPACK_IMPORTED_MODULE_1__.default`Handlers`, v);\n\n  // cache \n    const cache = {};\n    // deux\n    const d = R;\n    const e = d;\n    const u = X;\n    const x = u;\n\n  // main exports \n    Object.assign(R,{s,attrskip,skip,attrmarkup,markup,guardEmptyHandlers,die});\n\n    if ( DEBUG ) {\n      Object.assign(self, {d,u,T: _types_js__WEBPACK_IMPORTED_MODULE_1__.default}); \n    }\n\n    function R(p,...v) {\n      return exoteric(p,v);\n    }\n\n    function X(p,...v) {\n      return exoteric(p,v,{useCache:false});\n    }\n\n  // main function (TODO: should we refactor?)\n    function exoteric(p,v,{useCache:useCache=true}={}) {\n      const retVal = {};\n      let instanceKey, cacheKey;\n\n      v = v.map(guardAndTransformVal);\n\n      if ( useCache ) {\n        ({key:instanceKey} = (v.find(isKey) || {}));\n        cacheKey = p.join('<link rel=join>');\n        const {cached,firstCall} = isCached(cacheKey,v,instanceKey);\n       \n        if ( ! firstCall ) {\n          cached.update(v);\n          return cached;\n        } else {\n          retVal.oldVals = Array.from(v);\n        }\n      } else {\n        retVal.oldVals = Array.from(v);\n      }\n      \n      // compile the template into an updater\n\n      p = [...p]; \n      const vmap = {};\n      const V = v.map(replaceValWithKeyAndOmitInstanceKey(vmap));\n      const externals = [];\n      let str = '';\n\n      while( p.length > 1 ) str += p.shift() + V.shift();\n      str += p.shift();\n\n      const frag = toDOM(str);\n      const walker = document.createTreeWalker(frag, NodeFilter.SHOW_ALL);\n\n      do {\n        makeUpdaters({walker,vmap,externals});\n      } while(walker.nextNode())\n\n      Object.assign(retVal, {\n        externals,\n        v:Object.values(vmap),\n        to,\n        update,\n        code:_common_js__WEBPACK_IMPORTED_MODULE_0__.CODE,\n        nodes:[...frag.childNodes]\n      });\n\n      if ( useCache ) {\n        if ( instanceKey ) {\n          cache[cacheKey].instances[instanceKey] = retVal;\n        } else {\n          cache[cacheKey] = retVal;\n        }\n      }\n\n      return retVal;\n    }\n\n  // to function\n    function to(location, options) {\n      const position = (options || 'replace').toLocaleLowerCase();\n      const frag = document.createDocumentFragment();\n      this.nodes.forEach(n => frag.appendChild(n));\n      const isNode = _types_js__WEBPACK_IMPORTED_MODULE_1__.default.check(_types_js__WEBPACK_IMPORTED_MODULE_1__.default`>Node`, location);\n      const elem = isNode ? location : document.querySelector(location);\n      try {\n        MOVE[position](frag,elem);\n      } catch(e) {\n        DEBUG && console.log({location,options,e,elem,isNode});\n        DEBUG && console.warn(e);\n        switch(e.constructor && e.constructor.name) {\n          case \"DOMException\":      die({error: INSERT()},e);             break;\n          case \"TypeError\":         die({error: NOTFOUND(location)},e);   break; \n          default:                  throw e;\n        }\n      }\n      while(this.externals.length) {\n        this.externals.shift()();\n      }\n    }\n\n  // update functions\n    function makeUpdaters({walker,vmap,externals}) {\n      const node = walker.currentNode;\n      switch( node.nodeType ) {\n        case Node.ELEMENT_NODE:\n          handleElement({node,vmap,externals}); break;\n        case Node.COMMENT_NODE:\n        case Node.TEXT_NODE:\n          handleNode({node,vmap,externals}); break;\n      }\n    }\n\n    function handleNode({node,vmap,externals}) {\n      const lengths = [];\n      const text = node.nodeValue; \n      let result = KEYMATCH.exec(text);\n      while ( result ) {\n        const {index} = result;\n        const key = result[1];\n        const val = vmap[key];\n        const replacer = makeNodeUpdater({node,index,lengths,val});\n        externals.push(() => replacer(val.val));\n        val.replacers.push( replacer );\n        result = KEYMATCH.exec(text);\n      }\n    }\n\n    // node functions\n      function makeNodeUpdater(nodeState) {\n        const {node} = nodeState;\n        const scope = Object.assign({}, nodeState, {\n          oldVal: {length: KEYLEN},\n          oldNodes: [node],\n          lastAnchor: node,\n        });\n        return (newVal) => {\n          if ( scope.oldVal == newVal ) return;\n          scope.val.val = newVal;\n          switch(getType(newVal)) {\n            case \"markupobject\": \n            case \"brutalobject\":\n              handleMarkupInNode(newVal, scope); break;\n            default:\n              handleTextInNode(newVal, scope); break;\n          }\n        };\n      }\n\n      function handleMarkupInNode(newVal, state) {\n        let {oldNodes,lastAnchor} = state;\n        if ( newVal.nodes.length ) {\n          if ( sameOrder(oldNodes,newVal.nodes) ) {\n            // do nothing\n          } else {\n            Array.from(newVal.nodes).reverse().forEach(n => {\n              lastAnchor.parentNode.insertBefore(n,lastAnchor.nextSibling);\n              state.lastAnchor = lastAnchor.nextSibling;\n            });\n            state.lastAnchor = newVal.nodes[0];\n          }\n        } else {\n          const placeholderNode = summonPlaceholder(lastAnchor);\n          lastAnchor.parentNode.insertBefore(placeholderNode,lastAnchor.nextSibling);\n          state.lastAnchor = placeholderNode;\n        }\n        // MARK: Unbond event might be relevant here.\n        const dn = diffNodes(oldNodes,newVal.nodes);\n        if ( dn.size ) {\n          const f = document.createDocumentFragment();\n          dn.forEach(n => f.appendChild(n));\n        }\n        state.oldNodes = newVal.nodes || [lastAnchor];\n        while ( newVal.externals.length ) {\n          const func = newVal.externals.shift();\n          func();\n        } \n      }\n\n      function sameOrder(nodesA, nodesB) {\n        if ( nodesA.length != nodesB.length ) return false;\n\n        return Array.from(nodesA).every((an,i) => an == nodesB[i]);\n      }\n\n      function handleTextInNode(newVal, state) {\n        let {oldVal, index, val, lengths, node} = state;\n\n        const valIndex = val.vi;\n        const originalLengthBefore = Object.keys(lengths.slice(0,valIndex)).length*KEYLEN;\n        const lengthBefore = lengths.slice(0,valIndex).reduce((sum,x) => sum + x, 0);\n        const value = node.nodeValue;\n\n        lengths[valIndex] = newVal.length;\n\n        const correction = lengthBefore-originalLengthBefore;\n        const before = value.slice(0,index+correction);\n        const after = value.slice(index+correction+oldVal.length);\n\n        const newValue = before + newVal + after;\n\n        node.nodeValue = newValue;\n\n        state.oldVal = newVal;\n      }\n\n    // element attribute functions\n      function handleElement({node,vmap,externals}) {\n        getAttributes(node).forEach(({name,value} = {}) => {\n          const attrState = {node, vmap, externals, name, lengths: []};\n\n          KEYMATCH.lastIndex = 0;\n          let result = KEYMATCH.exec(name);\n          while( result ) {\n            prepareAttributeUpdater(result, attrState, {updateName:true});\n            result = KEYMATCH.exec(name);\n          }\n\n          KEYMATCH.lastIndex = 0;\n          result = KEYMATCH.exec(value);\n          while( result ) {\n            prepareAttributeUpdater(result, attrState, {updateName:false});\n            result = KEYMATCH.exec(value);\n          }\n        });\n      }\n\n      function prepareAttributeUpdater(result, attrState, {updateName}) {\n        const {index, input} = result;\n        const scope = Object.assign({}, attrState, {\n          index, input, updateName, \n          val: attrState.vmap[result[1]],\n          oldVal: {length: KEYLEN},\n          oldName: attrState.name,\n        });\n\n        let replacer;\n        if ( updateName ) {\n          replacer = makeAttributeNameUpdater(scope);\n        } else {\n          replacer = makeAttributeValueUpdater(scope);\n        }\n\n        scope.externals.push(() => replacer(scope.val.val));\n        scope.val.replacers.push( replacer );\n      }\n\n      // FIXME: needs to support multiple replacements just like value\n      // QUESTION: why is the variable oldName so required here, why can't we call it oldVal?\n      // if we do it breaks, WHY?\n      function makeAttributeNameUpdater(scope) {\n        let {oldName,node,val} = scope;\n        return (newVal) => {\n          if ( oldName == newVal ) return;\n          val.val = newVal;\n          const attr = node.hasAttribute(oldName) ? oldName : ''\n          if ( attr !== newVal ) {\n            if ( attr ) {\n              node.removeAttribute(oldName);\n              node[oldName] = undefined;\n            }\n            if ( newVal ) {\n              newVal = newVal.trim();\n\n              let name = newVal, value = undefined;\n\n              if( ATTRMATCH.test(newVal) ) {\n                const assignmentIndex = newVal.indexOf('='); \n                ([name,value] = [newVal.slice(0,assignmentIndex), newVal.slice(assignmentIndex+1)]);\n              }\n\n              reliablySetAttribute(node, name, value);\n            }\n            oldName = newVal;\n          }\n        };\n      }\n\n      function makeAttributeValueUpdater(scope) {\n        return (newVal) => {\n          if ( scope.oldVal == newVal ) return;\n          scope.val.val = newVal;\n          switch(getType(newVal)) {\n            case \"funcarray\":       updateAttrWithFuncarrayValue(newVal, scope); break;\n            case \"function\":        updateAttrWithFunctionValue(newVal, scope); break;\n            case \"handlers\":        updateAttrWithHandlersValue(newVal, scope); break;\n            case \"markupobject\":     \n            case \"brutalobject\": \n              newVal = nodesToStr(newVal.nodes); \n              updateAttrWithTextValue(newVal, scope); break;\n            /* eslint-disable no-fallthrough */\n            case \"markupattrobject\":  // deliberate fall through\n              newVal = newVal.str;\n            default:                \n              updateAttrWithTextValue(newVal, scope); break;\n            /* eslint-enable no-fallthrough */\n          }\n        };\n      }\n\n  // helpers\n    function getAttributes(node) {\n      if ( ! node.hasAttribute ) return [];\n\n      // for parity with classList.add (which trims whitespace)\n        // otherwise once the classList manipulation happens\n        // our indexes for replacement will be off\n      if ( node.hasAttribute('class') ) {\n        node.setAttribute('class', formatClassListValue(node.getAttribute('class')));\n      }\n      if ( !! node.attributes && Number.isInteger(node.attributes.length) ) return Array.from(node.attributes);\n      const attrs = [];\n      for ( const name of node ) {\n        if ( node.hasAttribute(name) ) {\n          attrs.push({name, value:node.getAttribute(name)});\n        }\n      }\n      return attrs;\n    }\n\n    function updateAttrWithFunctionValue(newVal, scope) {\n      let {oldVal,node,name,externals} = scope;\n      if ( name !== 'bond' ) {\n        let flags = {};\n        if ( name.includes(':') ) {\n          ([name, ...flags] = name.split(':'));\n          flags = flags.reduce((O,f) => {\n            O[f] = true;\n            return O;\n          }, {});\n        }\n        if ( oldVal ) {\n          node.removeEventListener(name, oldVal, flags);\n        }\n        node.addEventListener(name, newVal, flags); \n      } else {\n        if ( oldVal ) {\n          const index = externals.indexOf(oldVal);\n          if ( index >= 0 ) {\n            externals.splice(index,1);\n          }\n        }\n        externals.push(() => newVal(node)); \n      }\n      scope.oldVal = newVal;\n    }\n\n    function updateAttrWithFuncarrayValue(newVal, scope) {\n      let {oldVal,node,name,externals} = scope;\n      if ( oldVal && ! Array.isArray(oldVal) ) {\n        oldVal = [oldVal]; \n      }\n      if ( name !== 'bond' ) {\n        let flags = {};\n        if ( name.includes(':') ) {\n          ([name, ...flags] = name.split(':'));\n          flags = flags.reduce((O,f) => {\n            O[f] = true;\n            return O;\n          }, {});\n        }\n        if ( oldVal ) {\n          oldVal.forEach(of => node.removeEventListener(name, of, flags));\n        }\n        newVal.forEach(f => node.addEventListener(name, f, flags));\n      } else {\n        if ( oldVal ) {\n          oldVal.forEach(of => {\n            const index = externals.indexOf(of);\n            if ( index >= 0 ) {\n              externals.splice(index,1);\n            }\n          });\n        }\n        newVal.forEach(f => externals.push(() => f(node)));\n      }\n      scope.oldVal = newVal;\n    }\n\n    function updateAttrWithHandlersValue(newVal, scope) {\n      let {oldVal,node,externals,} = scope;\n      if ( !!oldVal && _types_js__WEBPACK_IMPORTED_MODULE_1__.default.check(_types_js__WEBPACK_IMPORTED_MODULE_1__.default`Handlers`, oldVal) ) {\n        Object.entries(oldVal).forEach(([eventName,funcVal]) => {\n          if ( eventName !== 'bond' ) {\n            let flags = {};\n            if ( eventName.includes(':') ) {\n              ([eventName, ...flags] = eventName.split(':'));\n              flags = flags.reduce((O,f) => {\n                O[f] = true;\n                return O;\n              }, {});\n            }\n            console.log(eventName, funcVal, flags);\n            node.removeEventListener(eventName, funcVal, flags); \n          } else {\n            const index = externals.indexOf(funcVal);\n            if ( index >= 0 ) {\n              externals.splice(index,1);\n            }\n          }\n        });\n      }\n      Object.entries(newVal).forEach(([eventName,funcVal]) => {\n        if ( eventName !== 'bond' ) {\n          let flags = {};\n          if ( eventName.includes(':') ) {\n            ([eventName, ...flags] = eventName.split(':'));\n            flags = flags.reduce((O,f) => {\n              O[f] = true;\n              return O;\n            }, {});\n          }\n          node.addEventListener(eventName, funcVal, flags); \n        } else {\n          externals.push(() => funcVal(node)); \n        }\n      });\n      scope.oldVal = newVal;\n    }\n\n    function updateAttrWithTextValue(newVal, scope) {\n      let {oldVal,node,index,name,val,lengths} = scope;\n      let zeroWidthCorrection = 0;\n      const valIndex = val.vi;\n      const originalLengthBefore = Object.keys(lengths.slice(0,valIndex)).length*KEYLEN;\n        \n      // we need to trim newVal to have parity with classlist add\n        // the reason we have zeroWidthCorrection = -1\n        // is because the classList is a set of non-zero width tokens\n        // separated by spaces\n        // when we have a zero width token, we have two adjacent spaces\n        // which, by virtue of our other requirement, gets replaced by a single space\n        // effectively elliding out our replacement location\n        // in order to keep our replacement location in tact\n        // we need to compensate for the loss of a token slot (effectively a token + a space)\n        // and having a -1 correction effectively does this.\n      if ( name == \"class\" ) {\n        newVal = newVal.trim();\n        if ( newVal.length == 0 ) {\n          zeroWidthCorrection = -1;\n        }\n        scope.val.val = newVal;\n      }\n      lengths[valIndex] = newVal.length + zeroWidthCorrection;\n      let attr = node.getAttribute(name);\n\n      const lengthBefore = lengths.slice(0,valIndex).reduce((sum,x) => sum + x, 0);\n\n      const correction = lengthBefore-originalLengthBefore;\n      const before = attr.slice(0,index+correction);\n      const after = attr.slice(index+correction+oldVal.length);\n\n      let newAttrValue;\n      \n      if ( name == \"class\" ) {\n        const spacer = oldVal.length == 0 ? ' ' : '';\n        newAttrValue = before + spacer + newVal + spacer + after;\n      } else {\n        newAttrValue = before + newVal + after;\n      }\n\n      DEBUG && console.log(JSON.stringify({\n        newVal,\n        valIndex,\n        lengths,\n        attr,\n        lengthBefore,\n        originalLengthBefore,\n        correction,\n        before,\n        after,\n        newAttrValue\n      }, null, 2));\n\n      reliablySetAttribute(node, name, newAttrValue);\n\n      scope.oldVal = newVal;\n    }\n\n    function reliablySetAttribute(node, name, value ) {\n      if (  name == \"class\" ) {\n        value = formatClassListValue(value);\n      }\n\n      try {\n        node.setAttribute(name,value);\n      } catch(e) {\n        DEBUG && console.warn(e);\n      }\n\n      try {\n        node[name] = value == undefined ? true : value;\n      } catch(e) {\n        DEBUG && console.warn(e);\n      }\n    }\n\n    function getType(val) {\n      const type = _types_js__WEBPACK_IMPORTED_MODULE_1__.default.check(_types_js__WEBPACK_IMPORTED_MODULE_1__.default`Function`, val) ? 'function' :\n        _types_js__WEBPACK_IMPORTED_MODULE_1__.default.check(_types_js__WEBPACK_IMPORTED_MODULE_1__.default`Handlers`, val) ? 'handlers' : \n        _types_js__WEBPACK_IMPORTED_MODULE_1__.default.check(_types_js__WEBPACK_IMPORTED_MODULE_1__.default`BrutalObject`, val) ? 'brutalobject' : \n        _types_js__WEBPACK_IMPORTED_MODULE_1__.default.check(_types_js__WEBPACK_IMPORTED_MODULE_1__.default`MarkupObject`, val) ? 'markupobject' :\n        _types_js__WEBPACK_IMPORTED_MODULE_1__.default.check(_types_js__WEBPACK_IMPORTED_MODULE_1__.default`MarkupAttrObject`, val) ? 'markupattrobject' :\n        _types_js__WEBPACK_IMPORTED_MODULE_1__.default.check(_types_js__WEBPACK_IMPORTED_MODULE_1__.default`BrutalArray`, val) ? 'brutalarray' : \n        _types_js__WEBPACK_IMPORTED_MODULE_1__.default.check(_types_js__WEBPACK_IMPORTED_MODULE_1__.default`FuncArray`, val) ? 'funcarray' : \n        'default'\n      ;\n      return type;\n    }\n\n    function summonPlaceholder(sibling) {\n      let ph = [...sibling.parentNode.childNodes].find(\n        node => node.nodeType == Node.COMMENT_NODE && node.nodeValue == 'brutal-placeholder' );\n      if ( ! ph ) {\n        ph = toDOM(`<!--brutal-placeholder-->`).firstChild;\n      }\n      return ph;\n    }\n\n    // cache helpers\n      // FIXME: function needs refactor\n      function isCached(cacheKey,v,instanceKey) {\n        let firstCall;\n        let cached = cache[cacheKey];\n        if ( cached == undefined ) {\n          cached = cache[cacheKey] = {};\n          if ( instanceKey ) {\n            cached.instances = {};\n            cached = cached.instances[instanceKey] = {};\n          }\n          firstCall = true;\n        } else {\n          if ( instanceKey ) {\n            if ( ! cached.instances ) {\n              cached.instances = {};\n              firstCall = true;\n            } else {\n              cached = cached.instances[instanceKey];\n              if ( ! cached ) {\n                firstCall = true;\n              } else {\n                firstCall = false;\n              }\n            }\n          } else {\n            firstCall = false;\n          }\n        }\n        return {cached,firstCall};\n      }\n\n    // Markup helpers\n      // Returns an object that Brutal treats as markup,\n      // even tho it is NOT a Brutal Object (defined with R/X/$)\n      // And even tho it is in the location of a template value replacement\n      // Which would normally be the treated as String\n      function markup(str) {\n        str = _types_js__WEBPACK_IMPORTED_MODULE_1__.default.check(_types_js__WEBPACK_IMPORTED_MODULE_1__.default`None`, str) ? '' : str; \n        const frag = toDOM(str);\n        const retVal = {\n          type: 'MarkupObject',\n          code:_common_js__WEBPACK_IMPORTED_MODULE_0__.CODE,\n          nodes:[...frag.childNodes],\n          externals: []\n        };\n        return retVal;\n      }\n\n      // Returns an object that Brutal treats, again, as markup\n      // But this time markup that is OKAY to have within a quoted attribute\n      function attrmarkup(str) {\n        str = _types_js__WEBPACK_IMPORTED_MODULE_1__.default.check(_types_js__WEBPACK_IMPORTED_MODULE_1__.default`None`, str) ? '' : str; \n        str = str.replace(/\"/g,'&quot;');\n        const retVal = {\n          type: 'MarkupAttrObject',\n          code: _common_js__WEBPACK_IMPORTED_MODULE_0__.CODE,\n          str\n        };\n        return retVal;\n      }\n\n      function guardEmptyHandlers(val) {\n        if ( Array.isArray(val) ) {\n          if ( val.length == 0 ) {\n            return [NULLFUNC]\n          } \n          return val;\n        } else {\n          if ( _types_js__WEBPACK_IMPORTED_MODULE_1__.default.check(_types_js__WEBPACK_IMPORTED_MODULE_1__.default`None`, val) ) {\n            return NULLFUNC;\n          }\n        }\n      }\n\n    // other helpers\n      function formatClassListValue(value) {\n        value = value.trim();\n        value = value.replace(/\\s+/g, ' ');\n        return value;\n      }\n\n      function replaceValWithKeyAndOmitInstanceKey(vmap) {\n        return (val,vi) => {\n          // omit instance key\n          if ( _types_js__WEBPACK_IMPORTED_MODULE_1__.default.check(_types_js__WEBPACK_IMPORTED_MODULE_1__.default`Key`, val) ) {\n            return '';\n          }\n          const key = ('key'+Math.random()).replace('.','').padEnd(KEYLEN,'0').slice(0,KEYLEN);\n          let k = key;\n          if ( _types_js__WEBPACK_IMPORTED_MODULE_1__.default.check(_types_js__WEBPACK_IMPORTED_MODULE_1__.default`BrutalObject`, val) || _types_js__WEBPACK_IMPORTED_MODULE_1__.default.check(_types_js__WEBPACK_IMPORTED_MODULE_1__.default`MarkupObject`, val) ) {\n            k = `<!--${k}-->`;\n          }\n          vmap[key.trim()] = {vi,val,replacers:[]};\n          return k;\n        };\n      }\n\n      function toDOM(str) {\n        const templateEl = (new DOMParser).parseFromString(\n          `<template>${str}</template>`,\"text/html\"\n        ).head.firstElementChild;\n        let f;\n        if ( templateEl instanceof HTMLTemplateElement ) { \n          f = templateEl.content;\n          f.normalize();\n          return f;\n        } else {\n          throw new TypeError(`Could not find template element after parsing string to DOM:\\n=START=\\n${str}\\n=END=`);\n        }\n      }\n\n      function guardAndTransformVal(v) {\n        const isFunc          = _types_js__WEBPACK_IMPORTED_MODULE_1__.default.check(_types_js__WEBPACK_IMPORTED_MODULE_1__.default`Function`, v);\n        const isUnset         = _types_js__WEBPACK_IMPORTED_MODULE_1__.default.check(_types_js__WEBPACK_IMPORTED_MODULE_1__.default`None`, v);\n        const isObject        = _types_js__WEBPACK_IMPORTED_MODULE_1__.default.check(_types_js__WEBPACK_IMPORTED_MODULE_1__.default`Object`, v);\n        const isBrutalArray   = _types_js__WEBPACK_IMPORTED_MODULE_1__.default.check(_types_js__WEBPACK_IMPORTED_MODULE_1__.default`BrutalArray`, v);\n        const isFuncArray     = _types_js__WEBPACK_IMPORTED_MODULE_1__.default.check(_types_js__WEBPACK_IMPORTED_MODULE_1__.default`FuncArray`, v);\n        const isMarkupObject    = _types_js__WEBPACK_IMPORTED_MODULE_1__.default.check(_types_js__WEBPACK_IMPORTED_MODULE_1__.default`MarkupObject`, v);\n        const isMarkupAttrObject= _types_js__WEBPACK_IMPORTED_MODULE_1__.default.check(_types_js__WEBPACK_IMPORTED_MODULE_1__.default`MarkupAttrObject`, v);\n        const isBrutal        = _types_js__WEBPACK_IMPORTED_MODULE_1__.default.check(_types_js__WEBPACK_IMPORTED_MODULE_1__.default`BrutalObject`, v);\n        const isForgery       = _types_js__WEBPACK_IMPORTED_MODULE_1__.default.check(_types_js__WEBPACK_IMPORTED_MODULE_1__.default`BrutalLikeObject`, v)  && !isBrutal; \n\n        if ( isFunc )         return v;\n        if ( isBrutal )       return v;\n        if ( isKey(v) )       return v;\n        if ( isHandlers(v) )  return v;\n        if ( isBrutalArray )  return join(v); \n        if ( isFuncArray )    return v;\n        if ( isMarkupObject )   return v;\n        if ( isMarkupAttrObject)return v;\n        if ( isUnset )        die({error: UNSET()});\n        if ( isForgery )      die({error: XSS()});\n        if ( isObject )       die({error: OBJ()});\n\n        return v+'';\n      }\n\n      function join(os) {\n        const externals = [];\n        const bigNodes = [];\n        const v = [];\n        const oldVals = [];\n        os.forEach(o => {\n          //v.push(...o.v); \n          //oldVals.push(...o.oldVals);\n          externals.push(...o.externals);\n          bigNodes.push(...o.nodes);\n        });\n        DEBUG && console.log({oldVals,v});\n        const retVal = {v,code:_common_js__WEBPACK_IMPORTED_MODULE_0__.CODE,oldVals,nodes:bigNodes,to,update,externals};\n        return retVal;\n      }\n\n      function nodesToStr(nodes) {\n        const frag = document.createDocumentFragment();\n        nodes.forEach(n => frag.appendChild(n.cloneNode(true)));\n        const container = document.createElement('body');\n        container.appendChild(frag);\n        return container.innerHTML;\n      }\n\n      function diffNodes(last,next) {\n        last = new Set(last);\n        next = new Set(next);\n        return new Set([...last].filter(n => !next.has(n)));\n      }\n\n      function update(newVals) {\n        const updateable = this.v.filter(({vi}) => didChange(newVals[vi], this.oldVals[vi]));\n        DEBUG && console.log({updateable, oldVals:this.oldVals, newVals});\n        updateable.forEach(({vi,replacers}) => replacers.forEach(f => f(newVals[vi])));\n        this.oldVals = Array.from(newVals);\n      }\n\n      function didChange(oldVal, newVal) {\n        DEBUG && console.log({oldVal,newVal});\n        const [oldType, newType] = [oldVal, newVal].map(getType); \n        let ret;\n        if ( oldType != newType ) {\n          ret =  true;\n        } else {\n          switch(oldType) {\n            case \"brutalobject\":\n              // the brutal object is returned by a view function\n              // which has already called its updaters and checked its slot values\n              // to determine and show changes\n              // except in the case of a list of nodes\n              ret = true;\n              break;\n            /* eslint-disable no-fallthrough */\n            case \"funcarray\":\n            case \"function\":\n              // hard to equate even if same str value as scope could be diff\n              ret = true;\n              break;\n            case \"brutalarray\":\n              // need to do array dif so don't do here\n              ret = true;\n              break;\n            case \"markupattrobject\":\n            case \"markupobject\":\n              // need to check multiple things\n              ret = true;\n              break;\n            default:\n              ret = JSON.stringify(oldVal) !== JSON.stringify(newVal);\n              break;\n            /* eslint-enable no-fallthrough */\n          }\n        }\n\n        DEBUG && console.log({ret});\n        return ret;\n      }\n\n  // reporting and error helpers \n    function die(msg,err) {\n      if (DEBUG && err) console.warn(err);\n      msg.stack = ((DEBUG && err) || new Error()).stack.split(/\\s*\\n\\s*/g);\n      throw JSON.stringify(msg,null,2);\n    }\n\n    function s(msg) {\n      if ( DEBUG ) {\n        console.log(JSON.stringify(msg,showNodes,2));\n        console.info('.');\n      }\n    }\n\n    function showNodes(k,v) {\n      let out = v;\n      if ( _types_js__WEBPACK_IMPORTED_MODULE_1__.default.check(_types_js__WEBPACK_IMPORTED_MODULE_1__.default`>Node`, v) ) {\n        out = `<${v.nodeName.toLowerCase()} ${\n          !v.attributes ? '' : [...v.attributes].map(({name,value}) => `${name}='${value}'`).join(' ')}>${\n          v.nodeValue || (v.children && v.children.length <= 1 ? v.innerText : '')}`;\n      } else if ( typeof v === \"function\" ) {\n        return `${v.name || 'anon'}() { ... }`\n      }\n      return out;\n    }\n\n\n//# sourceURL=webpack://@dosy-private/front-end/./public/src/web_modules/exoteric/r.js?");

/***/ }),

/***/ "./public/src/web_modules/exoteric/t.js":
/*!**********************************************!*\
  !*** ./public/src/web_modules/exoteric/t.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"T\": () => (/* binding */ T)\n/* harmony export */ });\n\n  const BuiltIns = [\n    Symbol, Boolean, Number, String, Object, Set, Map, WeakMap, WeakSet,\n    Uint8Array, Uint16Array, Uint32Array, Float32Array, Float64Array,\n    Int8Array, Int16Array, Int32Array, \n    Uint8ClampedArray, \n    Node,NodeList,Element,HTMLElement, Blob, ArrayBuffer,\n    FileList, Text, HTMLDocument, Document, DocumentFragment,\n    Error, File, Event, EventTarget, URL\n  ]\n\n  const DEBUG = false;\n  const SEALED_DEFAULT = true;\n  const isNone = instance => instance == null || instance == undefined;\n\n  const typeCache = new Map();\n\n  T.def = def;\n  T.check = check;\n  T.sub = sub;\n  T.verify = verify;\n  T.validate = validate;\n  T.partialMatch = partialMatch;\n  T.defEnum = defEnum;\n  T.defSub = defSub;\n  T.defTuple = defTuple;\n  T.defCollection = defCollection;\n  T.defOr = defOr;\n  T.option = option;\n  T.defOption = defOption;\n  T.maybe = maybe;\n  T.guard = guard;\n  T.errors = errors;\n\n  // debug\n  if ( DEBUG ) {\n    self.T = T;\n    self.typeCache = typeCache;\n  }\n\n  T[Symbol.for('jtype-system.typeCache')] = typeCache;\n\n  defineSpecials();\n  mapBuiltins();\n\n  function T(parts, ...vals) {\n    const cooked = vals.reduce((prev,cur,i) => prev+cur+parts[i+1], parts[0]);\n    const typeName = cooked;\n    if ( !typeCache.has(typeName) ) throw new TypeError(`Cannot use type ${typeName} before it is defined.`);\n    return typeCache.get(typeName).type;\n  }\n\n  function partialMatch(type, instance) {\n    return validate(type, instance, {partial:true});\n  }\n\n  function validate(type, instance, {partial: partial = false} = {}) {\n    guardType(type);\n    guardExists(type);\n    const typeName = type.name;\n\n    const {spec,kind,help,verify,verifiers,sealed} = typeCache.get(typeName);\n\n    const specKeyPaths = spec ? allKeyPaths(spec).sort() : [];\n    const specKeyPathSet = new Set(specKeyPaths);\n\n    const bigErrors = [];\n\n    switch(kind) {\n      case \"def\": {\n        let allValid = true;\n        if ( spec ) {\n          const keyPaths = partial ? allKeyPaths(instance, specKeyPathSet) : specKeyPaths;\n          allValid = !isNone(instance) && keyPaths.every(kp => {\n            // Allow lookup errors if the type match for the key path can include None\n\n            const {resolved, errors:lookupErrors} = lookup(instance,kp,() => checkTypeMatch(lookup(spec,kp).resolved, T`None`));\n            bigErrors.push(...lookupErrors);\n\n            if ( lookupErrors.length ) return false;\n\n            const keyType = lookup(spec,kp).resolved;\n            if ( !keyType || !(keyType instanceof Type) ) {\n              bigErrors.push({\n                error: `Key path '${kp}' is not present in the spec for type '${typeName}'`\n              });\n              return false;\n            }\n\n            const {valid, errors: validationErrors} = validate(keyType, resolved);\n            bigErrors.push(...validationErrors);\n\n            return valid;\n          });\n        }\n        let verified = true;\n        if ( partial && ! spec && !!verify ) {\n          throw new TypeError(`Type checking with option 'partial' is not a valid option for types that` + \n            ` only use a verify function but have no spec`);\n        } else if ( verify ) {\n          try {\n            verified = verify(instance);\n            if ( ! verified ) {\n              if ( verifiers ) {\n                throw {\n                  error:`Type ${typeName} value '${JSON.stringify(instance)}' violated at least 1 verify function in:\\n${\n                    verifiers.map(f => '\\t'+(f.help||'') + ' ('+f.verify.toString()+')').join('\\n')\n                  }`\n                };\n              } else if ( type.isSumType ) {\n                throw {\n                  error: `Value '${JSON.stringify(instance)}' did not match any of: ${[...type.types.keys()].map(t => t.name)}`,\n                  verify, verifiers\n                }\n              } else {\n                let helpMsg = '';\n                if ( help ) {\n                  helpMsg = `Help: ${help}. `;\n                }\n                throw {error:`${helpMsg}Type ${typeName} Value '${JSON.stringify(instance)}' violated verify function in: ${verify.toString()}`};\n              }\n            }\n          } catch(e) {\n            bigErrors.push(e);\n            verified = false;\n          }\n        }\n        let sealValid = true;\n        if ( !!sealed && !! spec ) {\n          const type_key_paths = specKeyPaths;\n          const all_key_paths = allKeyPaths(instance, specKeyPathSet).sort();\n          sealValid  = all_key_paths.join(',') == type_key_paths.join(',');\n          if ( ! sealValid ) {\n            if ( all_key_paths.length < type_key_paths.length ) {\n              sealValid = true;\n            } else {\n              const errorKeys = [];\n              const tkp = new Set(type_key_paths); \n              for( const k of all_key_paths ) {\n                if ( ! tkp.has(k) ) {\n                  errorKeys.push({\n                    error: `Key path '${k}' is not in the spec for type ${typeName}`\n                  });\n                }\n              }\n              if ( errorKeys.length ) {\n                bigErrors.push(...errorKeys);\n              }\n            }\n          }\n        }\n        return {valid: allValid && verified && sealValid, errors: bigErrors, partial}\n      } case \"defCollection\": {\n        const {valid:containerValid, errors:containerErrors} = validate(spec.container, instance);\n        let membersValid = true;\n        let verified = true;\n\n        bigErrors.push(...containerErrors);\n        if ( partial ) {\n          throw new TypeError(`Type checking with option 'partial' is not a valid option for Collection types`);\n        } else {\n          if ( containerValid ) {\n             membersValid= [...instance].every(member => {\n              const {valid, errors} = validate(spec.member, member);\n              bigErrors.push(...errors);\n              return valid;\n            });\n          }\n          if ( verify ) {\n            try {\n              verified = verify(instance);\n            } catch(e) {\n              bigErrors.push(e);\n              verified = false;\n            }\n          }\n        }\n          \n        return {valid:containerValid && membersValid && verified, errors:bigErrors};\n      } default: {\n        throw new TypeError(`Checking for type kind ${kind} is not yet implemented.`);\n      }\n    }\n  }\n\n  function check(...args) {\n    return validate(...args).valid;\n  }\n\n  function lookup(obj, keyPath, canBeNone) {\n    if ( isNone(obj) ) throw new TypeError(`Lookup requires a non-unset object.`);\n\n    if ( !keyPath ) throw new TypeError(`keyPath must not be empty`);\n\n\n    const keys = keyPath.split(/\\./g);\n    const pathComplete = [];\n    const errors = [];\n\n    let resolved = obj;\n\n    while(keys.length) {\n      const nextKey = keys.shift();\n      resolved = resolved[nextKey];\n      pathComplete.push(nextKey);\n      if ( (resolved === null || resolved === undefined) ) {\n        if ( keys.length ) {\n          errors.push({\n            error: \n              `Lookup on key path '${keyPath}' failed at '` + \n              pathComplete.join('.') +\n              `' when ${resolved} was found at '${nextKey}'.` \n          });\n        } else if ( !!canBeNone && canBeNone() ) {\n          resolved = undefined;\n        } else {\n          errors.push({\n            error: \n              `Resolution on key path '${keyPath}' failed` + \n              `when ${resolved} was found at '${nextKey}' and the Type of this` +\n              `key's value cannot be None.`\n          });\n        }\n        break;\n      }\n    }\n    return {resolved,errors};\n  }\n\n  function checkTypeMatch(typeA, typeB) {\n    guardType(typeA);\n    guardExists(typeA);\n    guardType(typeB);\n    guardExists(typeB);\n\n    if ( typeA === typeB ) {\n      return true;\n    } else if ( typeA.isSumType && typeA.types.has(typeB) ) {\n      return true;\n    } else if ( typeB.isSumType && typeB.types.has(typeA) ) {\n      return true;\n    } else if ( typeA.name.startsWith('?') && typeB == T`None` ) {\n      return true;\n    } else if ( typeB.name.startsWith('?') && typeA == T`None` ) {\n      return true;\n    }\n\n    if ( typeA.name.startsWith('>') || typeB.name.startsWith('>') ) {\n      console.error(new Error(`Check type match has not been implemented for derived//sub types yet.`));\n    }\n\n    return false;\n  }\n\n  function option(type) {\n    return T`?${type.name}`;\n  }\n\n  function sub(type) {\n    return T`>${type.name}`;\n  }\n\n  function defSub(type, spec, {verify: verify = undefined, help:help = ''} = {}, name = '') {\n    guardType(type);\n    guardExists(type);\n\n    let verifiers;\n\n    if ( ! verify ) {\n      verify = () => true;\n    } \n\n    if ( type.native ) {\n      verifiers = [ {help,verify} ];\n      verify = i => i instanceof type.native;\n      const helpMsg = `Needs to be of type ${type.native.name}. ${help||''}`;\n      verifiers.push({help:helpMsg,verify});\n    }\n\n    const newType = def(`${name}>${type.name}`, spec, {verify,help, verifiers});\n    return newType;\n  }\n\n  function defEnum(name, ...values) {\n    if ( !name ) throw new TypeError(`Type must be named.`); \n    guardRedefinition(name);\n    \n    const valueSet = new Set(values);\n    const verify = i => valueSet.has(i);\n    const help = `Value of Enum type ${name} must be one of ${values.join(',')}`;\n\n    return def(name, null, {verify,help});\n  }\n\n  function exists(name) {\n    return typeCache.has(name);\n  }\n\n  function guardRedefinition(name) {\n    if ( exists(name) ) throw new TypeError(`Type ${name} cannot be redefined.`);\n  }\n\n  function allKeyPaths(o, specKeyPaths) {\n    const isTypeSpec = ! specKeyPaths;\n    const keyPaths = new Set();\n    return recurseObject(o, keyPaths, '');\n\n    function recurseObject(o, keyPathSet, lastLevel = '') {\n      const levelKeys = Object.getOwnPropertyNames(o); \n      const keyPaths = levelKeys\n        .map(k => lastLevel + (lastLevel.length ? '.' : '') + k)\n      levelKeys.forEach((k,i) => {\n        const v = o[k];\n        if ( isTypeSpec ) {\n          if ( v instanceof Type ) {\n            keyPathSet.add(keyPaths[i]);\n          } else if ( typeof v == \"object\" ) {\n            if ( ! Array.isArray(v) ) {\n              recurseObject(v, keyPathSet, keyPaths[i]);\n            } else {\n              DEBUG && console.warn({o,v,keyPathSet, lastLevel});\n              throw new TypeError(`We don't support Types that use Arrays as structure, just yet.`); \n            }\n          } else {\n            throw new TypeError(`Spec cannot contain leaf values that are not valid Types`);\n          }\n        } else {\n          if ( specKeyPaths.has(keyPaths[i]) ) {\n            keyPathSet.add(keyPaths[i]); \n          } else if ( typeof v == \"object\" ) {\n            if ( ! Array.isArray(v) ) {\n              recurseObject(v, keyPathSet, keyPaths[i]);\n            } else {\n              v.forEach((item,index) => recurseObject(item, keyPathSet, keyPaths[i] + '.' + index));\n              //throw new TypeError(`We don't support Instances that use Arrays as structure, just yet.`); \n            }\n          } else {\n            //console.warn(\"Spec has no such key\",  keyPaths[i]);\n            keyPathSet.add(keyPaths[i]);\n          }\n        }\n      });\n      return [...keyPathSet];\n    }\n  }\n\n  function defOption(type) {\n    guardType(type);\n    const typeName = type.name;\n    return T.def(`?${typeName}`, null, {verify: i => isUnset(i) || T.check(type,i)});\n  }\n\n  function maybe(type) {\n    try {\n      return defOption(type);\n    } catch(e) {\n      // console.log(`Option Type ${type.name} already declared.`, e);\n    }\n    return T`?${type.name}`;\n  }\n\n  function verify(...args) { return check(...args); }\n\n  function defCollection(name, {container, member}, {sealed: sealed = SEALED_DEFAULT, verify: verify = undefined} = {}) {\n    if ( !name ) throw new TypeError(`Type must be named.`); \n    if ( !container || !member ) throw new TypeError(`Type must be specified.`);\n    guardRedefinition(name);\n\n    const kind = 'defCollection';\n    const t = new Type(name);\n    const spec = {kind, spec: { container, member}, verify, sealed, type: t};\n    typeCache.set(name, spec);\n    return t;\n  }\n\n  function defTuple(name, {pattern}) {\n    if ( !name ) throw new TypeError(`Type must be named.`); \n    if ( !pattern ) throw new TypeError(`Type must be specified.`);\n    const kind = 'def';\n    const specObj = {};\n    pattern.forEach((type,key) => specObj[key] = type);\n    const t = new Type(name);\n    const spec = {kind, spec: specObj, type:t};\n    typeCache.set(name, spec);\n    return t;\n  }\n\n  function Type(name, mods = {}) {\n    if ( ! new.target ) throw new TypeError(`Type with new only.`);\n    Object.defineProperty(this,'name', {get: () => name});\n    this.typeName = name;\n\n    if ( mods.types ) {\n      const {types} = mods;\n      const typeSet = new Set(types);\n      Object.defineProperty(this,'isSumType', {get: () => true});\n      Object.defineProperty(this,'types', {get: () => typeSet});\n    }\n\n    if ( mods.native ) {\n      const {native} = mods;\n      Object.defineProperty(this,'native', {get: () => native});\n    }\n  }\n\n  Type.prototype.toString = function () {\n    return `${this.typeName} Type`;\n  };\n\n  function def(name, spec, {help:help = '', verify:verify = undefined, sealed:sealed = undefined, types:types = undefined, verifiers:verifiers = undefined, native:native = undefined} = {}) {\n    if ( !name ) throw new TypeError(`Type must be named.`); \n    guardRedefinition(name);\n\n    if ( name.startsWith('?') ) {\n      if ( spec ) {\n        throw new TypeError(`Option type can not have a spec.`);\n      } \n\n      if ( ! verify(null) ) {\n        throw new TypeError(`Option type must be OK to be unset.`);\n      }\n    }\n\n    const kind = 'def';\n    if ( sealed === undefined ) {\n      sealed = true;\n    }\n    const t = new Type(name, {types, native});\n    const cache = {spec,kind,help,verify,verifiers,sealed,types,native,type:t};\n    typeCache.set(name, cache);\n    return t;\n  }\n\n  function defOr(name, ...types) {\n    return T.def(name, null, {types, verify: i => types.some(t => check(t,i))});\n  }\n\n  function guard(type, instance) {\n    guardType(type);\n    guardExists(type);\n    const {valid, errors} = validate(type, instance);\n    if ( ! valid ) throw new TypeError(`Type ${type} requested, but item is not of that type: ${errors.join(', ')}`);\n  }\n\n  function guardType(t) {\n    //console.log(t);\n    if ( !(t instanceof Type) ) throw new TypeError(`Type must be a valid Type object.`);\n  }\n\n  function guardExists(t) {\n    const name = originalName(t);\n    if ( ! exists(name) ) throw new TypeError(`Type must exist. Type ${name} has not been defined.`);\n  }\n\n  function errors(...args) {\n    return validate(...args).errors;\n  }\n\n  function mapBuiltins() {\n    BuiltIns.forEach(t => def(originalName(t), null, {native: t, verify: i => originalName(i.constructor) === originalName(t)}));  \n    BuiltIns.forEach(t => defSub(T`${originalName(t)}`));  \n  }\n\n  function defineSpecials() {\n    T.def(`Any`, null, {verify: () => true});\n    T.def(`Some`, null, {verify: i => !isUnset(i)});\n    T.def(`None`, null, {verify: i => isUnset(i)});\n    T.def(`Function`, null, {verify: i => i instanceof Function});\n    T.def(`Integer`, null, {verify: i => Number.isInteger(i)});\n    T.def(`Array`, null, {verify: i => Array.isArray(i)});\n    T.def(`Iterable`, null, {verify: i => i[Symbol.iterator] instanceof Function});\n  }\n\n  function isUnset(i) {\n    return i === null || i === undefined;\n  }\n\n  function originalName(t) {\n    if (!!t && t.name) {\n      return t.name;\n    } \n    const oName = Object.prototype.toString.call(t).replace(/\\[object |\\]/g, '');\n    if ( oName.endsWith('Constructor') ) {\n      return oName.replace(/Constructor$/,'');\n    }\n    return oName;\n  }\n\n\n\n//# sourceURL=webpack://@dosy-private/front-end/./public/src/web_modules/exoteric/t.js?");

/***/ }),

/***/ "./public/src/web_modules/exoteric/types.js":
/*!**************************************************!*\
  !*** ./public/src/web_modules/exoteric/types.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"TKey\": () => (/* binding */ TKey),\n/* harmony export */   \"THandlers\": () => (/* binding */ THandlers),\n/* harmony export */   \"TFuncArray\": () => (/* binding */ TFuncArray),\n/* harmony export */   \"TEmptyArray\": () => (/* binding */ TEmptyArray),\n/* harmony export */   \"TMarkupObject\": () => (/* binding */ TMarkupObject),\n/* harmony export */   \"TMarkupAttrObject\": () => (/* binding */ TMarkupAttrObject),\n/* harmony export */   \"TBrutalLikeObject\": () => (/* binding */ TBrutalLikeObject),\n/* harmony export */   \"TBrutalObject\": () => (/* binding */ TBrutalObject),\n/* harmony export */   \"TBrutalArray\": () => (/* binding */ TBrutalArray),\n/* harmony export */   \"TSBrutalObject\": () => (/* binding */ TSBrutalObject),\n/* harmony export */   \"TSBrutalArray\": () => (/* binding */ TSBrutalArray),\n/* harmony export */   \"BS\": () => (/* binding */ BS),\n/* harmony export */   \"SSR\": () => (/* binding */ SSR),\n/* harmony export */   \"Types\": () => (/* binding */ Types)\n/* harmony export */ });\n/* harmony import */ var _t_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./t.js */ \"./public/src/web_modules/exoteric/t.js\");\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common.js */ \"./public/src/web_modules/exoteric/common.js\");\n// types\n  \n  \n\n  // T\n\n    /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_t_js__WEBPACK_IMPORTED_MODULE_0__.T);\n\n  // Both SSR and Browser\n\n    const TKey = _t_js__WEBPACK_IMPORTED_MODULE_0__.T.def('Key', {\n      key: _t_js__WEBPACK_IMPORTED_MODULE_0__.T.defOr('ValidKey', _t_js__WEBPACK_IMPORTED_MODULE_0__.T`String`, _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Number`)\n    });\n\n    const THandlers = _t_js__WEBPACK_IMPORTED_MODULE_0__.T.def('Handlers', null, {verify: i => {\n      const validObject = _t_js__WEBPACK_IMPORTED_MODULE_0__.T.check(_t_js__WEBPACK_IMPORTED_MODULE_0__.T`Object`, i);\n\n      if ( ! validObject ) return false;\n\n      const eventNames = Object.keys(i);\n      const handlerFuncs = Object.values(i);\n      const validNames = eventNames.every(name => _t_js__WEBPACK_IMPORTED_MODULE_0__.T.check(_t_js__WEBPACK_IMPORTED_MODULE_0__.T`String`, name));\n      const validFuncs = handlerFuncs.every(func => _t_js__WEBPACK_IMPORTED_MODULE_0__.T.check(_t_js__WEBPACK_IMPORTED_MODULE_0__.T`Function`, func));\n      const valid = validNames && validFuncs;\n\n      return valid;\n    }});\n\n    const TFuncArray = _t_js__WEBPACK_IMPORTED_MODULE_0__.T.defCollection('FuncArray', {\n      container: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Array`,\n      member: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Function`\n    });\n\n    const TEmptyArray = _t_js__WEBPACK_IMPORTED_MODULE_0__.T.def('EmptyArray', null, {verify: i => Array.isArray(i) && i.length == 0});\n\n    const TMarkupObject = _t_js__WEBPACK_IMPORTED_MODULE_0__.T.def('MarkupObject', {\n      type: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`String`,\n      code: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`String`,\n      nodes: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Array`,\n      externals: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Array`,\n    }, {verify: v => v.type == 'MarkupObject' && v.code == _common_js__WEBPACK_IMPORTED_MODULE_1__.CODE});\n\n    const TMarkupAttrObject = _t_js__WEBPACK_IMPORTED_MODULE_0__.T.def('MarkupAttrObject', {\n      type: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`String`,\n      code: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`String`,\n      str: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`String`\n    }, {verify: v => v.type == 'MarkupAttrObject' && v.code == _common_js__WEBPACK_IMPORTED_MODULE_1__.CODE});\n\n  // Browser side\n\n    const TBrutalLikeObject = _t_js__WEBPACK_IMPORTED_MODULE_0__.T.def('BrutalLikeObject', {\n      code: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`String`,\n      externals: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Array`,\n      nodes: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Array`,\n      to: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Function`,\n      update: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Function`,\n      v: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Array`,\n      oldVals: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Array`\n    });\n\n    const TBrutalObject = _t_js__WEBPACK_IMPORTED_MODULE_0__.T.def('BrutalObject', {\n      code: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`String`,\n      externals: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Array`,\n      nodes: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Array`,\n      to: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Function`,\n      update: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Function`,\n      v: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Array`,\n      oldVals: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Array`\n    }, {verify: v => verify(v)});\n\n    const TBrutalArray = _t_js__WEBPACK_IMPORTED_MODULE_0__.T.defCollection('BrutalArray', {\n      container: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Array`,\n      member: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`BrutalObject`\n    });\n\n  // SSR\n\n    const TSBrutalObject = _t_js__WEBPACK_IMPORTED_MODULE_0__.T.def('SBrutalObject', {\n      str: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`String`,\n      handlers: THandlers\n    });\n\n    const TSBrutalArray = _t_js__WEBPACK_IMPORTED_MODULE_0__.T.defCollection('SBrutalArray', {\n      container: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`Array`,\n      member: _t_js__WEBPACK_IMPORTED_MODULE_0__.T`SBrutalObject`\n    });\n\n  // export\n\n  const BS = {TKey,THandlers,TFuncArray,TBrutalObject,TBrutalLikeObject,TBrutalArray};\n\n  const SSR = {TKey,THandlers,TFuncArray,TSBrutalObject,TSBrutalArray};\n\n  const Types = {BS,SSR};\n\n\n  // verify function \n    function verify(v) {\n      return _common_js__WEBPACK_IMPORTED_MODULE_1__.CODE === v.code;\n    }\n\n\n\n//# sourceURL=webpack://@dosy-private/front-end/./public/src/web_modules/exoteric/types.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./public/src/app.js");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;